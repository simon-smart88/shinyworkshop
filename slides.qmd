---
title: "Shiny workshop"
subtitle: "Natural History Museum"
author: "Simon Smart"
format: 
  revealjs:
    logo: images/uol_logo.png
    chalkboard: true
server: shiny
date: "7 February 2024"
preload-iframes: true
---

## About me

```{css}
code.sourceCode {
  font-size: 0.8em;
}

table {
font-size: 30px
}

/*logo*/
.reveal .slide-logo {
  height: 100px !important;
  max-width: unset !important;
  max-height: unset !important;
}

/*Shiny input and outputs*/
.shiny-input-container, .shiny-bound-output {
box-sizing: border-box;
color: rgb(51, 51, 51);
font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 18px;
line-height: 20px;
margin-bottom: 15px;
max-width: 100%;
width: 300px
}


/*mermaid-diagrams*/
/*input, server, output*/
.sin > rect {
    fill: #81c9db !important;
}
.sser > rect {
    fill: #81db93 !important;
}
.sout > rect {
    fill: #9381db !important;
}


```

-   Background in plant sciences and agricultural science
-   Latecomer to R, only started in 2018
-   Software developer in Population Health Sciences at University of Leicester
-   Collaborating with Dave Redding on Disagapp for high resolution mapping of disease
-   <https://github.com/simon-smart88>

## Workshop overview
- Trying to be broad but shallow so you know what's possible, rather than narrow but exhaustive
- Please interrupt: If you're not sure then someone else isn't
- Aiming for 50:50 me talking:you writing
- Code examples are not always complete i.e. not all required arguments are used

## Overview for this morning
-   Introduction to Shiny
-   How writing Shiny code differs from normal R
-   Create example apps

## Overview for the afternoon
-   User interface design
-   Interactive maps
-   Deploying your app to the web
-   Common problems and debugging 

## What is Shiny?

-   R package developed by Posit/Rstudio, first released in 2012
-   Framework for developing interactive web apps using R
-   No need to learn any web development (html, css, javascript)
-   If you can do something in R, you can publish it online using Shiny

```{r}
## {=html} 
## {data-menu-title="Tomvision"}
##<iframe width="100%" height="100%" src="https://tomvision.shinyapps.io/tomvision/"</iframe>

## {background-iframe="https://web.niab.com/pym-dashboard/?page=sign_in" background-interactive="true"}

## {background-iframe="https://simonsmart.shinyapps.io/shinyscholar/" background-interactive="true"}
```

## Download materials

- `git clone https://github.com/simon-smart88/shinyworkshop`
```{r eval = FALSE, echo = TRUE}
download.file(url = "t.ly/Y6ZDH", destfile = "shinyworkshop.zip")
```

## Structure of a Shiny app

Shiny apps consist of a user interface object (UI) and a server object

```{r eval = FALSE, echo = TRUE}
ui <- fluidPage()

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

## Transfer between the UI and server
- The server function takes two `list()`-like objects as arguments:
    - `input$` where settings made in the UI are stored
        - Created for you by objects in the UI
        - Values are read-only
    - `output$` where objects created in the server that need to be displayed in the UI are stored
        - You declare them yourself

## Input and output IDs  
- The objects in `input$` and `output$` have an ID used to refer to them
- These must be unique or you will get errors
- For `input$` objects, the ID is always the first argument of the function used to create them:
```{r eval = FALSE, echo = TRUE}
textInput("my_first_input") 
#allows you to use this in server:
input$my_first_input
```

## Input and output IDs  
- For `output$` objects, you declare them and then reference them by ID in the UI:
```{r eval = FALSE, echo = TRUE}
output$my_first_output <- renderText("Hello world") 
#allows you to use this in UI:
textOutput("my_first_output")
```

## Reactivity basics
::: columns
::: {.column width="70%"}
- Code in the server function is *reactive*
- If an input value changes, then any code which uses the input is rerun
- Similarly, any code which uses a value calculated from the input is also rerun
- Unlike in a normal R script, code isn't executed from top to bottom
:::
::: {.column width="30%"}
```{mermaid}
%%| fig-width: 6
flowchart TD
A[Input in UI] --> |input$| B([Computation in server])
B --> |output$| C(Output in UI)

class A sin
class B sser
class C sout
```
:::
:::

## A simple example
::: columns
::: {.column width="80%"}
```{r eval = FALSE, echo = TRUE}
ui <- fluidPage(textInput("name", "What is your name?"),
                textOutput("name_out"))

server <- function(input, output) {
  output$name_out <- renderText(paste0("My name is ", input$name))
}

shinyApp(ui = ui, server = server)
```

```{r}
br()
textInput("name", "What is your name?")
textOutput("name_out")
```

```{r}
#| context: server
output$name_out <- renderText(paste0("My name is ",input$name))
```
:::
::: {.column width="20%"}
```{mermaid}
%%| fig-width: 6
flowchart TD
A["textInput()"] --> |input$name| B(["renderText()"])
B --> |output$name_out| C("textOutput()")

class A sin
class B sser
class C sout

```
:::
:::

## Another example

```{r eval = FALSE, echo = TRUE}
ui <- fluidPage(selectInput("animal", "Choose your favourite animal", 
                            choices = c("","Whale", "Dinosaur")),
                textOutput("animal_name"))

server <- function(input, output) {
  output$animal_name <- renderText({
    animal_names = list("Whale" = "Hope", "Dinosaur" = "Dippy")
    paste0("Your favourite animal's name is ",animal_names[[input$animal]])})
}

shinyApp(ui = ui, server = server)
```

::: columns
::: {.column width="30%"}
```{r}
br()
selectInput("animal", "Choose your favourite animal", choices=c("", "Whale", "Dinosaur"))
```
:::
::: {.column width="70%"}
```{r}
br()
textOutput("animal_name")
htmlOutput("animal_photo")
```
:::
:::

```{r}
#| context: server
 output$animal_name <- renderText({
    animal_names = list("Whale" = "Hope", "Dinosaur" = "Dippy")
    paste0("Your favourite animal's name is ",animal_names[[input$animal]])
    })

output$animal_photo <- renderUI({
  req(input$animal)
  url <- switch(input$animal,
  Dinosaur = "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Diplodocus_%28replica%29.001_-_London.JPG/1280px-Diplodocus_%28replica%29.001_-_London.JPG",
  Whale = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Blue_Whale_-_Natural_History_Museum%2C_London_-_Joy_of_Museums.jpg/1280px-Blue_Whale_-_Natural_History_Museum%2C_London_-_Joy_of_Museums.jpg")
  
  credit <- switch(input$animal,
  Dinosaur = '<a href="https://commons.wikimedia.org/wiki/User:Drow_male" style="font-size:10px;">Fernando Losada Rodr√≠guez</a>',
  Whale = '<a href="https://commons.wikimedia.org/wiki/User:Joyofmuseums" style="font-size:10px;">Joyofmuseums</a>')
  
  HTML(glue::glue('<img src="{url}" height="200px">{credit}'))
})
```

## Static code can be put in different places
```{r eval = FALSE, echo = TRUE}
df <- read.csv()

ui <- fluidPage()

server <- function(input, output) {
  
  df <- read.csv()
  
  output$output <- renderTable({
    df <- read.csv()
  })
}  

shinyApp(ui = ui, server = server)
```

## Static code can be put in different places
```{r eval = FALSE, echo = TRUE}
df <- read.csv()
# run once when the app starts

ui <- fluidPage()

server <- function(input, output) {
  
  df <- read.csv()
  # run whenever a new user uses the app
  
  output$output <- renderTable({
    df <- read.csv()
    # run whenever input$value changes
    df <- df[df$column == input$value,]
  })
}  

shinyApp(ui = ui, server = server)
```


## Shiny input widgets

::: columns
::: {.column width="30%"}
```{r eval = FALSE, echo = TRUE}
actionButton()
checkboxInput()
dateInput()
dateRangeInput()
fileInput()
numericInput()
radioButtons()
selectInput()
sliderInput()
textInput()
```
:::

::: {.column width="70%"}
![](images/basic-widgets.png){height="400px"}
:::
:::

Source: <https://shiny.posit.co/r/getstarted/shiny-basics/lesson3/>
```{r}
##  {background-iframe="https://gallery.shinyapps.io/081-widgets-gallery/" background-interactive="true"}
```

## Output functions

Outputs are generated in the server using `render*` functions and displayed in the UI using `*Output` functions

| Data type         | Render function     |     Output function |
|-------------------|---------------------|--------------------:|
| Table             | `renderTable()`     |     `tableOutput()` |
| Plot              | `renderPlot()`      |      `plotOutput()` |
| Text              | `renderText()`      |      `textOutput()` |
| Image             | `renderImage()`     |     `imageOutput()` |
| Interactive table | `renderDataTable()` | `dataTableOutput()` |

## Curly bracket syntax
-   Typically `render*()` functions are used with curly brackets `{}` inside the function
-   This lets you write multiple lines of code, but only the last line is returned

## UI development

-   `fluidPage()` makes the design *responsive* so that it fits on different sized screens 
-   The UI object is one long list
-   Objects need separating by commas 
-   Brackets are important for structuring layout of elements
-   Tabs and lines help to make your code readable
-   It can get very complicated!

## Server development
-   Shiny code is more complex to debug and errors may not be simple to understand
-   Some mistakes won't produce any errors at all
-   It is often helpful to write code in an .Rmd file first and then refactor for reactivity
-   Start simple and build complexity gradually
-   If you don't already, use the F1 key to look at documentation

## Exercise 1

Create an app where you:

-   Load data from `iris`
-   Filter the data in some way using `sliderInput()`, `numericInput()` or `selectInput()`
-   Display the output using `renderTable()` and `tableOutput()`

```{r}
head(iris)
unique(iris$Species)
```

## `reactive()`
-   If you want to access an `input$` you must do so inside reactive objects
-   You have already done this - all the `render*` function are reactive
-   If you want to create an object without making an output though, you need to wrap it inside `reactive()`
-   The resultant object is a function, so you need to append `()` when you access the values

## `reactive()` example

‚ùå

```{r echo=TRUE, eval=FALSE}
df <- iris[iris$Species == input$species,]
min_petal_length <- min(df$Petal.Length)
```

‚úÖ

```{r echo=TRUE, eval=FALSE}
df <- reactive(iris[iris$Species == input$species,])
min_petal_length <- min(df()$Petal.Length)
```

## File uploads
-   `fileInput()` uploads the file to the web server, but not into the R environment
-   The resulting `input$` value is a dataframe containing `name`, `size`, `type` and `datapath` columns
-   To access the data, you need to process the file using the `datapath` column e.g.:

```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload file")
df <- reactive(read.csv(input$file$datapath))
```

## `renderUI()` and `uiOutput()`
-   These functions can be used to generate UI elements containing values reliant on other inputs

```{r echo=TRUE, eval=FALSE}
#UI:
numericInput("max_value", "Max value", value = 10)
uiOutput("my_widget")
textOutput("slider_value")
#Server:
output$my_widget <- renderUI({
  sliderInput("slider", "Value", value = 5, min = 1, max = input$max_value)
  })
output$slider_value <- renderText(input$slider)
```

```{r}
br()
numericInput("max_value", "Max value", value = 10)
uiOutput("my_widget")
textOutput("slider_value")
```

```{r}
#| context: server
output$my_widget <- renderUI({sliderInput("slider", "Value", value = 5, min = 1, max = input$max_value)})
output$slider_value <- renderText(input$slider)
```

## Controlling reactivity

- Reactivity is essential for creating an interactive application but requires managing:
    - What if some of your functions take seconds or minutes to run?
    - What if your function uses an `input$` which is `NULL` when the app initiates?

## Using `req()`
- `req()` is used to control execution of a function by defining the values that it *requires*
- Placed at the top of reactive functions i.e. `reactive()` and `render*()`
- If the conditions are not met, execution is halted

```{r echo=TRUE, eval=FALSE}
req(input$file) #checks that the input is not NULL
req(input$name == "Simon") #checks a specific condition 
req(input$file, some_setting == "correct") #checks both conditions
```

## Using `validate()`
- `validate()` is similar to `req()` but more user-friendly as errors can be passed back to the UI
```{r echo = TRUE, eval = FALSE}


```

## Using `actionButton` and `observeEvent()`

UI:
```{r echo = TRUE, eval = FALSE}
actionButton("go", "Go!")
```

Server:
```{r echo = TRUE, eval = FALSE}
observeEvent(input$go, {
    #do stuff  
})
```


UI:
```{r echo = TRUE, eval = FALSE}
actionButton("go", "Go!")
textOutput("pressed")
```

Server:
```{r echo = TRUE, eval = FALSE}
observeEvent(input$go, {
      
})
```





## Exercise 2

:::columns
::: {.column width="50%"}
Create an app where you:
-   Upload a spreadsheet - `fileInput()`
-   Select the names of two columns - `renderUI()` and `selectInput()`
-   Plot the two columns in a scatter plot - `renderPlot()`
-   Optional extra:
        - Use `actionButton` and `bindEvent()` to control when the plot is rendered
:::
::: {.column width="50%"}
```{mermaid}
flowchart TD
A["fileInput('file' ...)"] --> |input$file| B(["renderUI({<br/>selectInput(<br/>'variable_two' ...)<br/>})"])
A --> |input$file| C(["renderUI({<br/>selectInput(<br/>'variable_one' ...)<br/>})"])
B --> |output$select_two| D("uiOutput('select_two')")
C --> |output$select_one| E("uiOutput('select_one')")
E --> |input$variable_one|F
D --> |input$variable_two|F(["renderPlot()"])
F --> |output$plot|G("plotOutput('plot')")

class A sin
class B sser
class C sser
class D sout
class E sout
class F sser
class G sout
```
:::
:::

## Applications vs. scripts 
- Execution is circular, not linear
- Applications have users and users can break things
- What happens if you write this, but a user uploads a `.jpeg` instead of `.csv`?
- Need to try and consider all the possibilities and manage them
```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload .csv file")
df <- reactive({req(input$file)
                read.csv(input$file$datapath)})
```

## Applications vs. scripts 
- Execution is circular, not linear
- Applications have users and users can break things
- What happens if you write this, but a user uploads a `.jpeg` instead of `.csv`?
- Need to try and consider all the possibilities and manage them
```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload .csv file", accept = ".csv")
df <- reactive({req(input$file)
                ext <- tools::file_ext(input$file$datapath)
                validate(need(ext == "csv"), "Please upload a .csv file")
                read.csv(input$file$datapath)  
                })
```


## Downloads


## Exercise 3
- UI layout
- Leaflet
- Download 

## Interactive maps
- `{leaflet}` is a package for creating interactive maps
- `renderLeaflet()` for the server and `leafletOutput()` for the UI

```{r echo=TRUE, eval=FALSE}
output$map <- renderLeaflet({
  leaflet() %>%
    addPolygons(sf_object) %>%
    addRasterImage(raster_image) %>%
    terra::plet(terra_object) #currently requires dev version: 
                              #remotes::install_github("rstudio/leaflet")
})
```

## More leaflet
- Many different options for background maps, legends, symbols, pop-ups, zooming, controlling visible layers
- `{leaflet.extras}` has tools for drawing shapes on the map which can be used to edit data
- You will normally want to use `leafletProxy()` which prevents completely re-rendering the map whenever something changes:

```{r echo=TRUE, eval=FALSE}
output$map <- renderLeaflet({
  leaflet() %>%
    addPolygons(sf_object)
  })

observe({
    map %>%
      addRasterImage(raster_image[values(raster_image) > input$threshold])
})
```

## UI layouts

## Themes
- Themes can be used to change the appearance of all the elements of an app in one go
- `fluidPage(theme = bslib::bs_theme("<theme name>"))`
- [bootswatch.com](https://bootswatch.com/)
```{=html}
<iframe width="1000" height="400" src="https://bootswatch.com/" title="Bootswatch"></iframe>
```

## Cascading style sheets
- css determines the appearance of elements on web pages
- You can add your own css to the UI to change how elements appear
- Right-clicking / Ctrl+clicking allows you to inspect the html 
- Often requires trial and error!
```{r echo = TRUE, eval = FALSE}
ui <- fluidPage(
  tags$head(
      tags$style(type="text/css", 
                 ".shiny-output-error-validation {color: green; font-size: 18px}"
      )))
```

## File structures
- Standalone as `app.R`
- Separate files for server and UI - `server.R` and `ui.R`
- `global.R` - loaded before `server.R` and `ui.R` so can be a good place to load data 

## Templates



## Common pitfalls
-   Trying to use reactive objects in a non-reactive context



-   Not appending reactive objects with `()` when accessing their values
-   Naming a `reactive()` variable the same as a loaded function
-   Typos in `input` or `output` IDs
-   Using the same id twice
-   Misplaced brackets or commas in UI

## Debugging
-   Apps are run in their own environment, so you can't inspect objects in the Rstudio environment tab
-   Run the code in a standard R script or .Rmd to check it works as you expect
-   Use `verbatimTextOutput()` and `textOutput()` to display objects - are they in the state you expect?
-   Include `options(shiny.fullstacktrace = TRUE)` in the server
-   Add `browser()` above where your code is failing and then inspect the objects in your environment
-   Create a simple app containing only the problematic elements (i.e. a minimal, reproducible example)

## Deployment
-   Publish your app so that others can use it
-   We will use [shinyapps.io](https://shinyapps.io)
-   Free and easy to use but has limitations:
    - Only 1GB RAM on free tiers which may not be enough to run models
    - Limited amount of use per month
    - No persistent data storage
-   Many other options available

## What happens when you deploy
- Copies the code from the app directory
- Uses `{renv}` to check your R version and what package versions the app uses
- Replicates the environment of your machine on their server 
- R runs on their server and sends the results to the browser

## Create an account
-   Register

## Resources

- [Get started guide from Posit](https://shiny.posit.co/r/getstarted/)
- [Mastering Shiny](https://mastering-shiny.org/)
- [Outstanding User Interfaces with Shiny](https://unleash-shiny.rinterface.com/)
- [Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/)
