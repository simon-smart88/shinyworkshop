---
title: "Shiny workshop"
subtitle: "Natural History Museum"
author: "Simon Smart"
format: 
  revealjs:
    logo: images/uol_logo.png
    chalkboard: true
    code-line-numbers: false
server: shiny
date: "7 February 2024"
preload-iframes: true
---

## About me

```{css}
code.sourceCode {
  font-size: 0.8em;
}

.largecode code.sourceCode {
font-size: 1.5em;
}

li.smalltext {
font-size: 30px;
}

table {
font-size: 30px;
}

/*logo*/
.reveal .slide-logo {
  height: 100px !important;
  max-width: unset !important;
  max-height: unset !important;
}

/*Shiny input and outputs*/
.shiny-input-container, .shiny-bound-output, .shiny-input-text {
box-sizing: border-box;
color: rgb(51, 51, 51);
font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 25px;
line-height: 28px;
margin-bottom: 15px;
max-width: 100%;
width: 300px
}


/*mermaid-diagrams*/
/*input, server, output*/
.sin > rect {
    fill: #81c9db !important;
}
.sser > rect {
    fill: #81db93 !important;
}
.sout > rect {
    fill: #9381db !important;
}


```

```{r eval=TRUE, echo=FALSE}
library(shiny)
library(dplyr)
library(leaflet)
```

-   Background in plant sciences and agricultural science
-   Latecomer to R, only started in 2018
-   Software developer in Population Health Sciences at University of Leicester with Tim Lucas
-   Collaborating with Dave Redding on Disagapp for high resolution mapping of disease
-   <https://github.com/simon-smart88>

## Workshop overview

-   Trying to be broad but shallow so you know what's possible, rather than narrow but exhaustive
-   Please interrupt: If you're not sure then someone else isn't
-   Aiming for 50:50 me talking:you writing
-   Code examples are not always complete i.e. not all required arguments are used

## Overview for this morning

-   Introduction to Shiny
-   Reactivity and why writing Shiny code differs from normal R
-   Create example apps

## Overview for the afternoon

-   User interface design
-   Interactive maps
-   Deploying your app to the web
-   Common problems and debugging

## What is Shiny?

-   R package developed by Posit/Rstudio, first released in 2012
-   Framework for developing interactive web apps using R
-   No need to learn any web development (html, css, javascript)
-   If you can do something in R, you can publish it online using Shiny

## Download materials {.largecode}

-   `git clone https://github.com/simon-smart88/shinyworkshop`

```{r eval = FALSE, echo = TRUE}
unzip(download.file(url = "t.ly/Y6ZDH", destfile = "shinyworkshop.zip"))
```

-   For the slides to be interactive, you need to run `slides.qmd`

```{r}
## {data-menu-title="Tomvision"}
## {=html} 
##<iframe width="100%" height="100%" src="https://tomvision.shinyapps.io/tomvision/"</iframe>

## {data-menu-title="Potato dashboard"}
## {=html} 
##<iframe width="100%" height="100%" src="https://web.niab.com/pym-dashboard/?page=sign_in"</iframe>

## {data-menu-title="Shinyscholar"}
## {=html} 
##<iframe width="100%" height="100%" src="https://simonsmart.shinyapps.io/shinyscholar/"</iframe>
```

## Structure of a Shiny app {.largecode}

Shiny apps consist of a user interface object (UI) and a server object

```{r eval = FALSE, echo = TRUE}
ui <- fluidPage() 

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

## Structure of a Shiny app {.largecode}

Shiny apps consist of a user interface object (UI) and a server object

::: columns
::: {.column width="80%"}
```{r eval = FALSE, echo = TRUE}
ui <- fluidPage() 

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```
:::

::: {.column width="20%"}
-   Seeing

-   Doing
:::
:::

-   Our job is to make these objects talk to each other

## Communication between the UI and server

-   The server function takes two `list()`-like objects as arguments:
    -   `input$` where settings made in the UI are stored
        -   Created for you by objects in the UI
        -   Values are read-only
    -   `output$` where objects created in the server that need to be displayed in the UI are stored
        -   You create them

## Input and output IDs {.largecode}

-   The objects in `input$` and `output$` have an ID used to refer to them
-   These must be unique or you will get errors
-   For `input$` objects, the ID is always the first argument of the function used to create them:

```{r eval = FALSE, echo = TRUE}
textInput("my_first_input") 
#allows you to use this in server:
input$my_first_input
```

## Input and output IDs {.largecode}

-   For `output$` objects, you declare them and then reference them by ID in the UI:

```{r eval = FALSE, echo = TRUE}
output$my_first_output <- renderText("Hello world") 
#allows you to use this in UI:
textOutput("my_first_output")
```

-   Both are referenced as strings in the UI but as variables in the server

## Reactivity basics

::: columns
::: {.column width="70%"}
-   Code in the server function is *reactive*
-   If an `input$` value changes, then any code which uses the input is rerun
-   Similarly, any code that uses a value calculated from the input is also rerun
-   Unlike in a normal R script, code isn't executed from top to bottom
:::

::: {.column width="30%"}
```{mermaid}
%%| fig-width: 6
flowchart TD
A[Input in UI] --> |input$| B([Computation in server])
B --> |output$| C(Output in UI)

class A sin
class B sser
class C sout
```
:::
:::

## A simple example

::: columns
::: {.column width="80%"}
```{r eval = FALSE, echo = TRUE}
ui <- fluidPage(textInput("name", "What is your name?"),
                textOutput("name_out"))

server <- function(input, output) {
  output$name_out <- renderText(paste0("My name is ", input$name))
}

shinyApp(ui = ui, server = server)
```

```{r}
br()
textInput("name", "What is your name?")
textOutput("name_out")
```

```{r}
#| context: server
output$name_out <- renderText(paste0("My name is ",input$name))
```
:::

::: {.column width="20%"}
```{mermaid}
%%| fig-width: 6
flowchart TD
A["textInput()"] --> |input$name| B(["renderText()"])
B --> |output$name_out| C("textOutput()")

class A sin
class B sser
class C sout

```
:::
:::

## Another example

```{r eval = FALSE, echo = TRUE}
ui <- fluidPage(selectInput("animal", "Choose your favourite animal", 
                            choices = c("","Whale", "Dinosaur")),
                textOutput("animal_name"))

server <- function(input, output) {
  output$animal_name <- renderText({
    animal_names = list("Whale" = "Hope", "Dinosaur" = "Dippy")
    paste0("Your favourite animal's name is ",animal_names[[input$animal]])})
}

shinyApp(ui = ui, server = server)
```

::: columns
::: {.column width="40%"}
```{r}
br()
selectInput("animal", "Choose your favourite animal", choices=c("", "Whale", "Dinosaur"))
```
:::

::: {.column width="40%"}
```{r}
br()
textOutput("animal_name")
htmlOutput("animal_photo")
```
:::
:::

```{r}
#| context: server
 output$animal_name <- renderText({
    animal_names = list("Whale" = "Hope", "Dinosaur" = "Dippy")
    paste0("Your favourite animal's name is ",animal_names[[input$animal]])
    })

output$animal_photo <- renderUI({
  req(input$animal)
  url <- switch(input$animal,
  Dinosaur = "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Diplodocus_%28replica%29.001_-_London.JPG/1280px-Diplodocus_%28replica%29.001_-_London.JPG",
  Whale = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Blue_Whale_-_Natural_History_Museum%2C_London_-_Joy_of_Museums.jpg/1280px-Blue_Whale_-_Natural_History_Museum%2C_London_-_Joy_of_Museums.jpg")
  
  credit <- switch(input$animal,
  Dinosaur = '<a href="https://commons.wikimedia.org/wiki/User:Drow_male" style="font-size:10px;">Fernando Losada Rodríguez</a>',
  Whale = '<a href="https://commons.wikimedia.org/wiki/User:Joyofmuseums" style="font-size:10px;">Joyofmuseums</a>')
  
  HTML(glue::glue('<img src="{url}" height="200px">{credit}'))
})
```

## Static code can be put in different places

```{r eval = FALSE, echo = TRUE}
df <- read.csv()

ui <- fluidPage()

server <- function(input, output) {
  
  df <- read.csv()
  
  output$output <- renderTable({
    df <- read.csv()
  })
}  

shinyApp(ui = ui, server = server)
```

## Static code can be put in different places

```{r eval = FALSE, echo = TRUE}
df <- read.csv()
# run once when the app starts

ui <- fluidPage()

server <- function(input, output) {
  
  df <- read.csv()
  # run whenever a new user uses the app
  
  output$output <- renderTable({
    df <- read.csv()
    # run whenever input$value changes
    df <- df[df$column == input$value,]
  })
}  

shinyApp(ui = ui, server = server)
```

## Shiny input widgets

::: columns
::: {.column width="30%"}
```{r eval = FALSE, echo = TRUE}
actionButton()
checkboxInput()
dateInput()
dateRangeInput()
fileInput()
numericInput()
radioButtons()
selectInput()
sliderInput()
textInput()
```
:::

::: {.column width="70%"}
![](images/basic-widgets.png){height="400px"}
:::
:::

Source: <https://shiny.posit.co/r/getstarted/shiny-basics/lesson3/>

```{r}
##  {background-iframe="https://gallery.shinyapps.io/081-widgets-gallery/" background-interactive="true"}
```

## Output functions

Outputs are generated in the server using `render*` functions and displayed in the UI using `*Output` functions

| Data type         | Render function     |     Output function |
|-------------------|---------------------|--------------------:|
| Table             | `renderTable()`     |     `tableOutput()` |
| Plot              | `renderPlot()`      |      `plotOutput()` |
| Text              | `renderText()`      |      `textOutput()` |
| Image             | `renderImage()`     |     `imageOutput()` |
| Interactive table | `renderDataTable()` | `dataTableOutput()` |

## Curly bracket syntax

-   Typically `render*()` functions are used with curly brackets `{}` inside the function
-   This lets you write multiple lines of code, but only the last line is returned

## UI development {.largecode}

::: columns
::: {.column width="50%"}
-   The UI object is one long list
-   `fluidPage()` makes the design *responsive* so that it fits on different sized screens
-   The first item will be placed in the top left
-   Functions need separating by commas
:::
::: {.column width="50%"}
\

```{r echo=TRUE, eval=FALSE}
ui <- fluidPage(
      actionButton(),
      checkboxInput(),
      dateInput(),
      textOutput(),
      plotOutput(),
      tableOutput()
      )
```
:::
:::

## Server development

-   Shiny code is more complex to debug and errors may not be simple to understand
-   Some mistakes won't produce any errors at all
-   First write code in an .Rmd file and then refactor for reactivity
-   Start simple and build complexity gradually
-   If you don't already, use the F1 key to look at documentation

## tidyverse peculiarities

Unfortunately this will not work as you might expect:

```{r echo=TRUE, eval=FALSE}
#UI
selectInput("var", "Variable", choices = c("carat", "depth", "table", "price", "x", "y", "z"))
numericInput("min", "Minimum", value = 1)

#Server
data <- reactive(diamonds %>% filter(input$var > input$min))
```

## tidyverse peculiarities

-   This is the correct syntax:

```{r echo=TRUE, eval=FALSE}
data <- reactive(diamonds %>% filter(.data[[input$var]] > .env$input$min))
```

-   See [Mastering Shiny](https://mastering-shiny.org/action-tidy.html) for more details
-   For now, just use the old-fashioned method:

```{r echo=TRUE, eval=FALSE}
data <- reactive(diamonds[diamonds[[input$var]] > input$min,])
```

## Exercise 1

Create an app where you:

-   Load data from `iris`
-   Filter the data in some way using `sliderInput()`, `numericInput()` or `selectInput()`
-   Display the filtered data using `renderTable()` and `tableOutput()`

```{r}
head(iris)[0:3,]
unique(iris$Species)
```

## `reactive()`

-   If you want to access an `input$` you must do so inside reactive objects
-   You have already done this - all the `render*` function are reactive
-   If you want to create an object without making an output though, you need to wrap it inside `reactive()`
-   The resultant object is a function, so you need to append `()` when you access the values

## `reactive()` example {.largecode}

❌

```{r echo=TRUE, eval=FALSE}
df <- iris[iris$Species == input$species,]
min_petal_length <- min(df$Petal.Length)
```

✅

```{r echo=TRUE, eval=FALSE}
df <- reactive(iris[iris$Species == input$species,])
min_petal_length <- min(df()$Petal.Length)
```

## File uploads

-   `fileInput()` uploads the file to the web server, but not into the R environment
-   The resulting `input$` value is a dataframe containing `name`, `size`, `type` and `datapath` columns
-   To access the data, you need to process the file using the `datapath` column e.g.:

```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload file")
df <- reactive(read.csv(input$file$datapath))
```

## `renderUI()` and `uiOutput()`

-   Used to generate UI elements containing values reliant on other inputs

```{r echo=TRUE, eval=FALSE}
#UI:
numericInput("max_value", "Max value", value = 10)
uiOutput("my_widget")
textOutput("slider_value")
#Server:
output$my_widget <- renderUI({
  sliderInput("slider", "Value", value = 5, min = 1, max = input$max_value)
  })
output$slider_value <- renderText(input$slider)
```

```{r}
br()
numericInput("max_value", "Max value", value = 10)
uiOutput("my_widget")
textOutput("slider_value")
```

```{r}
#| context: server
output$my_widget <- renderUI({sliderInput("slider", "Value", value = 5, min = 1, max = input$max_value)})
output$slider_value <- renderText(input$slider)
```

## Controlling reactivity

-   Reactivity is essential for creating an interactive application but requires managing:
    -   What if some of your functions take seconds or minutes to run?
    -   What if your function uses an `input$` which is `NULL` when the app initiates?

## Using `req()`

-   `req()` is used to control execution of a function by defining the values that it *requires*
-   Placed at the top of reactive functions i.e. `reactive()` and `render*()`
-   If the conditions are not met, execution is halted

```{r echo=TRUE, eval=FALSE}
req(input$name) #checks that the input is not NULL
req(input$name == "Simon") #checks a specific condition 
req(input$name == "Simon", input$check == TRUE) #checks both conditions
```

::: columns
::: {.column width="30%"}
```{r}
br()
textInput("name1", "What is your name?")
checkboxInput("check1", "Tick me!", value = FALSE)
```
:::

::: {.column width="50%"}
```{r}
br()
textOutput("name_out1a")
textOutput("name_out1b")
textOutput("name_out1c")
```
:::
:::

```{r}
#| context: server
output$name_out1a <- renderText({
req(input$name1) 
"The first condition is satisfied"})

output$name_out1b <- renderText({
req(input$name1) 
req(input$name1 == "Simon")
"The first and second conditions are satisfied"})

output$name_out1c <- renderText({
req(input$name1) 
req(input$name1 == "Simon")
req(input$name1 == "Simon", input$check1 == TRUE)
  "All three conditions are satisfied"})
```

## Using `validate()`

-   `validate()` is similar to `req()` but more user-friendly as errors can be passed back to the UI

```{r echo = TRUE, eval = FALSE}
validate(need(input$name, "Please enter your name"))
validate(need(input$name == "Simon", "Your name must be Simon"))
validate(need(input$name == "Simon", "Your name must be Simon"),
         need(input$check == TRUE, "The checkbox must be ticked"))
```

```{r}
br()
textInput("name2", "What is your name?")
checkboxInput("check", "Tick me!", value = FALSE)
textOutput("name_out2")
```

```{r}
#| context: server
output$name_out2 <- renderText({
validate(need(input$name2, "Please enter your name"))
validate(need(input$name2 == "Simon", "Your name must be Simon"))
validate(need(input$name2 == "Simon", "Your name must be Simon"),
         need(input$check == TRUE, "The checkbox must be ticked"))
  paste0("My name is ",input$name2)})
```

## Using `actionButton()` and `bindEvent()` {.largecode}

-   Used to explicitly control when code is run

```{r echo = TRUE, eval = FALSE}
actionButton("go", "Do stuff") #UI
output$name_out <- renderText(input$name) %>% #Server
  bindEvent(input$go) 
```

```{r}
br()
textInput("name3", "What is your name?")
actionButton("go", "Do stuff")
textOutput("name_out3")
textOutput("action_value")
```

```{r}
#| context: server
library(dplyr)
output$name_out3 <- renderText({paste0("My name is ",input$name3)}) %>% bindEvent(input$go)
output$action_value <- renderText({
  req(input$go > 1)
  paste0("actionButton value = ", input$go)})
```

## Using `actionButton()` and `observeEvent()` {.largecode}

-   Similar to using `bindEvent()` but for use when the action doesn't produce an output

```{r echo = TRUE, eval = FALSE}
actionButton("go", "Go!") #UI
observeEvent(input$go, {do_stuff()}) #Server
```

```{r}
br()
numericInput("number", "Number to send", value = 10)
actionButton("go_db", "Send to database")
textOutput("database")
```

```{r}
#| context: server
database_value <- reactiveVal(value = 1)
observeEvent(input$go_db, {database_value(input$number)}) 
output$database <- renderText({
  paste0("The database value is: ", database_value())})
```

## Exercise 2 {.smalltext}

::: columns
::: {.column width="50%"}
Create an app where you:

-   Upload a spreadsheet - `fileInput()`
-   Select the names of two columns - `renderUI()` and `selectInput()`
-   Plot the two columns in a scatter plot - `renderPlot()`
-   Optional extra: - Use `actionButton` and `bindEvent()` to control when the plot is rendered
:::

::: {.column width="50%"}
```{mermaid}
flowchart TD
A["fileInput('file' ...)"] --> |input$file| B(["renderUI({<br/>selectInput(<br/>'variable_two' ...)<br/>})"])
A --> |input$file| C(["renderUI({<br/>selectInput(<br/>'variable_one' ...)<br/>})"])
B --> |output$select_two| D("uiOutput('select_two')")
C --> |output$select_one| E("uiOutput('select_one')")
E --> |input$variable_one|F
D --> |input$variable_two|F(["renderPlot()"])
F --> |output$plot|G("plotOutput('plot')")

class A sin
class B sser
class C sser
class D sout
class E sout
class F sser
class G sout
```
:::
:::

## Applications vs. scripts

-   Execution is circular, not linear
-   You are creating a range of possibilities for your user
-   Applications have users and users can break things
-   What happens if you write this, but a user uploads a `.jpeg` instead of `.csv`?
-   Need to try and consider all the possibilities and manage them

```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload .csv file")
df <- reactive({req(input$file)
                read.csv(input$file$datapath)})
```

## Applications vs. scripts

-   Execution is circular, not linear
-   You are creating a range of possibilities for your user
-   Applications have users and users can break things
-   What happens if you write this, but a user uploads a `.jpeg` instead of `.csv`?
-   Need to try and consider all the possibilities and manage them

```{r echo=TRUE, eval=FALSE}
fileInput("file", "Upload .csv file", accept = ".csv")
df <- reactive({req(input$file)
                ext <- tools::file_ext(input$file$datapath)
                validate(need(ext == "csv"), "Please upload a .csv file")
                read.csv(input$file$datapath)  
                })
```

## Downloads
-   `downloadButton()` in the UI
-   `downloadHandler()` in the server

```{r echo=TRUE, eval=FALSE}
downloadButton("download_data")

output$download_data <- downloadHandler(
      filename = function() {
      paste("data.csv", sep="")
    },
    content = function(file) {
      write.csv(data, file)
    }
)
```

## Exercise 3

-   UI layout
-   Leaflet
-   Download

## Interactive maps

-   `{leaflet}` is a package for creating interactive maps
-   `renderLeaflet()` for the server and `leafletOutput()` for the UI

```{r echo=TRUE, eval=FALSE}
output$map <- renderLeaflet({
  leaflet() %>%
    addPolygons(sf_object) %>%
    addRasterImage(raster_image) %>%
    terra::plet(terra_object) #currently requires dev version: 
                              #remotes::install_github("rstudio/leaflet")
})
```

## More leaflet

-   Many different options for background maps, legends, symbols, pop-ups, zooming, controlling visible layers
-   `{leaflet.extras}` has tools for drawing shapes on the map which can be used to edit data
-   You will normally want to use `leafletProxy()` which prevents completely re-rendering the map whenever something changes:

```{r echo=TRUE, eval=FALSE}
output$map <- renderLeaflet({
  leaflet() %>%
    addPolygons(sf_object)
  })

observe({
    map %>%
      addRasterImage(raster_image[values(raster_image) > input$threshold])
})
```

## UI layouts

-   Brackets are important for structuring layout of elements
-   Tabs and lines help to make your code readable
-   It can get very complicated!

## Themes

-   Themes can be used to change the appearance of all the elements of an app in one go
-   `fluidPage(theme = bslib::bs_theme("<theme name>"))`
-   [bootswatch.com](https://bootswatch.com/)

```{=html}
<iframe width="1000" height="400" src="https://bootswatch.com/" title="Bootswatch"></iframe>
```
## Cascading style sheets

-   css determines the appearance of elements on web pages
-   You can add your own css to the UI to change how elements appear
-   Right-clicking / Ctrl+clicking allows you to inspect the html
-   Often requires trial and error!

```{r echo = TRUE, eval = FALSE}
ui <- fluidPage(
  tags$head(
      tags$style(type="text/css", 
                 ".shiny-output-error-validation {color: green; font-size: 18px}"
      )))
```

## File structures

-   Various file structures can be used depending on complexity
-   Standalone as `app.R`
-   Separate files for server and UI - `server.R` and `ui.R`
-   `global.R` - loaded before `server.R` and `ui.R` so can be a good place to load data
-   If `server.R` and `ui.R` become very long, code can be modularised into infinite files

## Templates

## Common pitfalls

-   Trying to use reactive objects in a non-reactive context

-   Not appending reactive objects with `()` when accessing their values

-   Naming a `reactive()` variable the same as a loaded function

-   Typos in `input` or `output` IDs

-   Using the same ID twice

-   Misplaced brackets or commas in UI

## Debugging

-   Apps are run in their own environment, so you can't inspect objects in the Rstudio environment tab
-   Run the code in a standard R script or .Rmd to check it works as you expect
-   Use `verbatimTextOutput()` and `textOutput()` to display objects - are they in the state you expect?
-   Include `options(shiny.fullstacktrace = TRUE)` in the server
-   Add `browser()` above where your code is failing and then inspect the objects in your environment
-   Create a simple app containing only the problematic elements (i.e. a minimal, reproducible example)

## Deployment

-   Publish your app so that others can use it
-   We will use [shinyapps.io](https://shinyapps.io) run by Posit
-   Free and easy to use but has limitations:
    -   Only 1GB RAM on free tiers which may not be enough to run models
    -   Limited amount of use per month (25 hours)
    -   No persistent data storage
-   Many other options available

## What happens when you deploy

-   Copies the code from the app directory
-   Uses `{renv}` to check your R version and what package versions the app uses
-   Replicates the environment of your machine on their server
-   R runs on their server and sends the results to the browser

## How to deploy

-   Register: <https://www.shinyapps.io/auth/oauth/signup>
-   Copy your token and secret: <https://www.shinyapps.io/admin/#/tokens>
-   Click "Show" on right hand side and then "Show secret"
-   Copy and run the code which looks like this:

```{r echo=TRUE, eval = FALSE}
rsconnect::setAccountInfo(name='simonsmart',
			  token='E72042914BFED931FDE0C96A1',
			  secret='kowe90erweioj2312iuj2o4ij2jij')
```

## Resources

-   [Get started guide from Posit](https://shiny.posit.co/r/getstarted/)
-   [Mastering Shiny](https://mastering-shiny.org/)
-   [Outstanding User Interfaces with Shiny](https://unleash-shiny.rinterface.com/)
-   [Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/)
